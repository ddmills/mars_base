start
  = action+

action
  = w1:white action:word w2:white start:start_group w3:white statement:statement* w4:white end:end_group w5:white
  {
data = [];
literals = [];

 for (_i = 0, _len = statement.length; _i < _len; _i++) {
  part = statement[_i];
  data.push(part.value);
  literals.push(part.literal);
 }

return {action:action.value, statements:data, literals:literals,
begin:w1+action.literal+w2+start.literal+w3,
end:w4+end.literal+w5}}

word
  = w1:white string:[a-zA-Z_]+ w2:white 
  {return {type:'word', value:string.join(''), literal:w1+string.join('')+w2}}

white
  = string:(" " / newline / tab)* {return string.join('')}

newline =
  [\n] {return "\n" }

tab =
  [\t] {return "\t" }

statement
  = w1:white block:logic_block end:end_line w2:white
    { 
literal = ''; 
 for (_i = 0, _len = block.length; _i < _len; _i++) {
  part = block[_i];
  literal += part.literal
 }

return {type:'statement', value:block, literal:w1+literal+end.literal+w2} }

logic_block =
  w1:white parts:( word / number / operator / assignment / comparative / 
           memory / self / enclosure )+ w2:white
   {return parts }

number
  = w1:white number:(float / integer) w2:white
    {return {type:'number', value:number, literal:w1+number+w2}}

float
  = sign:"-"?
    before:[0-9]* "." after:[0-9]+ {
      return parseFloat(sign+before.join("") + "." + after.join(""));
    }

integer
  = sign:"-"?
    digits:[0-9]+ {
      return parseInt(sign+digits.join(""), 10);
    }

operator
  = w1:white operator:('+' / '-' / '/' / '*' / '%') w2:white
  {return {type:'operator', value:operator, literal:w1+operator+w2}}

assignment
  = w1:white "=" w2:white 
 {return {type:'assignment', value:'=', literal:w1+'='+w2}}

comparative
 = w1:white comp:('==' / '<' / '>' / '<=' / '>=' / '&') w2:white
  {return {type:'compare', value:comp, literal:w1+comp+w2}}


/* */

start_group
  = w1:white start:( '(' / '{' / '[' ) w2:white
  {return {type:'end_line', value:start, literal:w1+start+w2} }

end_group
  = w1:white end:( ')' / '}' / ']' ) w2:white
  {return {type:'end_line', value:end, literal:w1+end+w2} }

end_line
  = w1:white end:( ';' / ':' / ',' / '.' ) w2:white
  {return {type:'end_line', value:end, literal:w1+end+w2} }

enclosure =
  w1:white start:start_group w2:white block:logic_block w3:white end:end_group w4:white
  { 

literal = ''; 
 for (_i = 0, _len = block.length; _i < _len; _i++) {
  part = block[_i];
  literal += part.literal
 }

return {type:'enclosure' , value:block, 
literal:w1+start.literal+w2+literal+w3+end.literal+w2} }



/* game stuff */ 

memory
 = white sym:'$' slot:('i' / 'f' / 's' / 'l' / 'e') index:[0-9] white {return {type:'memory', slot:slot, index:index}}

self
  = white amp:'@' self:[a-zA-Z_]+ white {return {type:'self', value:self.join('') } }



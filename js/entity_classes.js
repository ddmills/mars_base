// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.phrases = {
    'help': ['help!', 'hey guys?', 'this is bad.', 'frack!', 'not good', 'oh no!'],
    'found': ['I see a $1', 'look, a $1'],
    'need': ['I need a $1', 'anybody seen a $1?'],
    'location': ['the $1 is over there', 'I saw a $1', 'look, $1', 'here is the $1'],
    'forget': ['no $1 here'],
    'greet': ['Nice to meet you, $1'],
    'sup': ['what are you up to?', "what's up?", 'hey $1'],
    'follow': ['follow me', 'come, $1', 'I need a hand'],
    'fail': ['I give up!', "Can't do the job.", 'Fail..']
  };

  $(window).ready(function() {
    var Colonist, Engineer, Talker, Walker;
    Walker = (function(_super) {

      __extends(Walker, _super);

      function Walker() {
        return Walker.__super__.constructor.apply(this, arguments);
      }

      Walker.prototype.init = function() {
        this.state = 'idle';
        this.speed = 4;
        this.turn_speed = .04;
        this.target = 0;
        this.path = 0;
        this.vector = this.normalize_vector(new Vector(0, 1, 0));
        this.new_vector = false;
        this.wait_time = 0;
        this.total_time = 0;
        this.frame_count = 0;
        this.footprint_img = 'prints';
        this.velcoity = .1;
        this.draw_prints = 0;
        this.rotate_sprite = 1;
        this.pos = [this.pos[0] - this.pos[0] % 32, this.pos[1] - this.pos[1] % 32];
        this.sprite_size = 32;
        this.sprite_offset = [0, 0];
        this.claimed = false;
        window.Entities.sentient.push(this);
        window.Entities.sentient_hash.add(this);
        return this.setup();
      };

      Walker.prototype.setup = function() {};

      Walker.prototype._get_objects_here = function() {
        var map;
        map = window.Map.get('objects', this.tile_pos[0], this.tile_pos[1]);
        if (map && map.length) {
          return map;
        }
        return [];
      };

      Walker.prototype.draw = function() {
        var hook, i, s, thing, x, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        _ref = this._get_objects_here();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          thing = _ref[_i];
          if (thing.visited) {
            thing.visited();
          }
        }
        this.draw_sprite();
        window.Draw.context.fillStyle = 'white';
        window.Draw.draw_text(this.state, this.pos[0] + 2, this.pos[1] + 43, {
          fillStyle: 'white',
          font: 'courier',
          fontsize: 8
        });
        _ref1 = this.debug;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          s = _ref1[i];
          window.Draw.draw_text(s, this.pos[0] + 18, this.pos[1] + i * 11, {
            fillStyle: 'white',
            font: 'courier',
            fontsize: 8
          });
        }
        this.debug = [];
        if (this.target) {
          x = this.target[0] * window.Map.tilesize;
          y = this.target[1] * window.Map.tilesize;
        }
        _ref2 = this.draw_hooks;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          hook = _ref2[_k];
          _results.push(this[hook]());
        }
        return _results;
      };

      Walker.prototype.draw_sprite = function() {
        var rotation;
        rotation = false;
        if (this.vector && this.rotate_sprite) {
          rotation = Math.atan2(this.vector.y, this.vector.x);
          rotation += Math.PI + Math.PI / 2;
        }
        if (this.footprint_img) {
          if (this.draw_prints) {
            this.draw_prints = 0;
            window.Draw.use_layer('background');
            window.Draw.image(this.footprint_img, this.pos[0], this.pos[1], 32, 32, rotation);
          }
        }
        window.Draw.use_layer('entities');
        return window.Draw.image(this.image, this.pos[0] + this.sprite_offset[0], this.pos[1] + this.sprite_offset[0], this.sprite_size, this.sprite_size, rotation);
      };

      Walker.prototype.normalize_vector = function(vector) {
        var len;
        len = vector.length();
        vector = vector.unit().multiply(this.speed);
        return vector;
      };

      Walker.prototype.get_random_tile = function(distance) {
        var x, y;
        if (distance == null) {
          distance = false;
        }
        if (!distance) {
          x = parseInt(Math.random() * window.Map.width);
          y = parseInt(Math.random() * window.Map.height);
        } else {
          x = parseInt((Math.random() * distance * 2) - distance) + this.tile_pos[0];
          y = parseInt((Math.random() * distance * 2) - distance) + this.tile_pos[1];
          x = window.util.constrict(x, 0, window.Map.width);
          y = window.util.constrict(y, 0, window.Map.height);
        }
        return [x, y];
      };

      Walker.prototype.path_to = function(pos) {
        var path;
        path = window.Entities.get_path(this.tile_pos[0], this.tile_pos[1], pos[0], pos[1]);
        if (path && (path.length != null) && path.length > 0) {
          this.path = path;
          this.state = 'moving';
          return true;
        } else {
          this.state = 'wait';
          return false;
        }
      };

      Walker.prototype.path_close_to = function(pos) {
        var i, j, path, _i, _j;
        path = window.Entities.get_path(this.tile_pos[0], this.tile_pos[1], pos[0], pos[1]);
        if (path && (path.length != null) && path.length > 0) {
          return path;
        } else {
          for (i = _i = -1; _i <= 1; i = ++_i) {
            for (j = _j = -1; _j <= 1; j = ++_j) {
              path = window.Entities.get_path(this.tile_pos[0], this.tile_pos[1], pos[0] + i, pos[1] + j);
              if (path && (path.length != null) && path.length > 0) {
                return path;
              }
            }
          }
        }
        return false;
      };

      Walker.prototype._idle = function() {
        var use;
        if ((this.state_que != null) && this.state_que.length > 0) {
          use = this.state_que.pop(0);
          this.state = use;
          return;
        }
        this.target = this.get_random_tile(10);
        return this.path_to(this.target);
      };

      Walker.prototype._wait = function() {
        this.wait_time += this.delta_time;
        if (this.wait_time > 600) {
          this.wait_time = 0;
          return this.state = 'idle';
        }
      };

      Walker.prototype._moving = function() {
        var near, p1, p2, tilesize;
        if (!(this.path != null) || this.path.length === 0) {
          this.state = 'wait';
          return;
        }
        tilesize = window.Map.tilesize;
        p1 = this.path[0][0] * tilesize;
        p2 = this.path[0][1] * tilesize;
        this.vect_to_target = new Vector((this.path[0][0] * tilesize) - this.pos[0], (this.path[0][1] * tilesize) - this.pos[1], 0);
        this.dist_to_target = this.vect_to_target.length();
        this.target_vect = this.normalize_vector(this.vect_to_target);
        this.vector = Vector.lerp(this.vector, this.target_vect, this.turn_speed);
        near = 10;
        if (this.pos[0] > p1 - near && this.pos[0] < p1 + near && this.pos[1] > p2 - near && this.pos[1] < p2 + near) {
          this.path = this.path.splice(1, this.path.length);
          this.velocity = .1;
          if (this.path.length === 0) {
            this.state = 'wait';
          }
        } else {
          return this.move(1);
        }
      };

      Walker.prototype.radians_between_vectors = function(v1, v2) {
        var l1, l2, l3;
        l1 = v1.unit();
        l2 = v2.unit();
        l3 = l1.subtract(l2);
        return l3.length();
      };

      Walker.prototype.move = function(friction) {
        var avoid, l, r;
        if (friction == null) {
          friction = .95;
        }
        this.vector = this.vector.multiply(.90);
        if (!this.vvv) {
          this.vvv = new Vector(0, 0, 0);
        }
        if (!this.dist_to_target) {
          return;
        }
        r = this.radians_between_vectors(this.vvv, this.vect_to_target);
        if (r > .5) {
          friction = 1 - r;
        }
        this.vvv = this.vvv.multiply(friction);
        this.vvv = this.vvv.add(this.vector.multiply(.2));
        if (this.vvv.length() > this.speed) {
          this.vvv = this.normalize_vector(this.vvv);
        }
        if (this.vvv.length() > this.speed / 3) {
          if (this.frame_count % 18 === 0) {
            this.draw_prints = 1;
          }
        }
        avoid = this.get_floor_avoidance();
        if ((avoid != null) && (avoid !== false && avoid !== (void 0)) && (avoid.x != null)) {
          l = avoid.length();
          if (l > 1) {
            if (l > 10) {
              avoid = avoid.unit().multiply(10);
            }
            this.pos[0] += avoid.x;
            this.pos[1] += avoid.y;
            window.Entities.sentient_hash.update_member(this);
            return;
          }
        }
        this.pos[0] += this.vvv.x;
        this.pos[1] += this.vvv.y;
        return window.Entities.sentient_hash.update_member(this);
      };

      Walker.prototype.get_floor_avoidance = function() {
        var count, i, j, n_v, nl, tile, v, x, y, _i, _j;
        v = new Vector(0, 0, 0);
        count = 0;
        for (i = _i = -1; _i <= 1; i = ++_i) {
          for (j = _j = -1; _j <= 1; j = ++_j) {
            tile = window.Map.get('pathfinding', this.tile_pos[0] + i, this.tile_pos[1] + j);
            if (tile === 1) {
              x = ((this.tile_pos[0] + i) * window.Map.tilesize) - this.pos[0];
              y = ((this.tile_pos[1] + j) * window.Map.tilesize) - this.pos[1];
              n_v = new Vector(x, y, 0);
              nl = n_v.length();
              count += 1;
              n_v = n_v.unit().multiply(32 / nl);
              v = v.add(n_v);
            }
          }
        }
        if (count > 0) {
          v = v.divide(count).multiply(.15);
          return v;
        }
        return false;
      };

      Walker.prototype._wait = function() {
        this.wait_time += this.delta_time;
        this.move(.8);
        if (this.wait_time > 600) {
          this.wait_time = 0;
          return this.state = 'idle';
        }
      };

      Walker.prototype.n_tiles_away = function(p1, p2, n) {
        if (p1[0] > p2[0] - n && p1[0] < p2[0] + n && p1[1] > p2[1] - n && p1[1] < p2[1] + n) {
          return true;
        }
      };

      Walker.prototype.find_unclaimed_object = function(nombre) {
        var distance, found, local, obj, path, _i, _len;
        found = false;
        distance = 2000;
        local = window.Entities.objects_hash.get_within([this.pos[0], this.pos[1]], distance);
        if (local) {
          for (_i = 0, _len = local.length; _i < _len; _i++) {
            obj = local[_i];
            if (obj.nombre === nombre) {
              if (!obj.claimed) {
                if (!(this.job === 'place' && obj.placed === true)) {
                  path = window.Entities.get_path(this.tile_pos[0], this.tile_pos[1], obj.tile_pos[0], obj.tile_pos[1]);
                  if (path && (path.length != null) && path.length > 0) {
                    this.path = path;
                    obj.claimed = true;
                    this.claim = obj;
                    return true;
                  }
                }
              }
            }
          }
        }
        return false;
      };

      return Walker;

    })(window.Entities.classes.Entity);
    Talker = (function(_super) {

      __extends(Talker, _super);

      function Talker() {
        return Talker.__super__.constructor.apply(this, arguments);
      }

      Talker.prototype.init_voice = function() {
        this.voice_que = [];
        this.hear_que = [];
        this.draw_hooks.push('draw_voice');
        this.wander_dist = 4;
        this.conversation_timer = 0;
        this.conversation_partner = false;
        return this.memory = {
          objects: {},
          entities: {}
        };
      };

      Talker.prototype.draw_voice = function() {
        var alpha, blackcolor, font, phlen, phrase, redcolor, whitecolor, ymod;
        if (Math.random() < .2) {
          this._process();
        }
        if ((this.voice_que != null) && this.voice_que.length > 0) {
          this.voice_que[0][1] += 1;
          phrase = this.voice_que[0][0];
          phlen = phrase.length * 10 + 10;
          window.Draw.use_layer('entities');
          alpha = 1 - this.voice_que[0][1] / 90;
          ymod = alpha * 30 - 30;
          if (!typeof alpha === "number") {
            alpha = 1.0;
          }
          whitecolor = 'rgba(255,255,255,' + alpha + ')';
          redcolor = 'rgba(255,0,0,' + alpha + ')';
          blackcolor = 'rgba(0,0,0,' + alpha + ')';
          font = {
            fillStyle: 'black',
            strokeStyle: 'black',
            font: 'courier',
            fontsize: 16
          };
          if (this.voice_que[0][2] === 'emergency') {
            font = {
              fillStyle: redcolor,
              strokeStyle: 'red',
              font: 'Comic Sans MS',
              fontsize: 20
            };
          }
          window.Draw.draw_box(this.pos[0], this.pos[1] - 20 + ymod, phlen, 20, {
            fillStyle: whitecolor,
            strokeStyle: 'black',
            lineWidth: 0
          });
          window.Draw.draw_lines([[this.pos[0] + 4, this.pos[1] + ymod], [this.pos[0] + 5 + 4, this.pos[1] + 7 + ymod], [this.pos[0] + 10 + 4, this.pos[1] + ymod]], {
            fillStyle: whitecolor,
            strokeStyle: 'white',
            lineWidth: 0
          });
          if (this.voice_que[0][1] > 90) {
            this.voice_que = this.voice_que.splice(1, this.voice_que.length);
          }
          if (this.voice_que.length > 4) {
            return this.voice_que = this.voice_que.splice(1, this.voice_que.length);
          }
        }
      };

      Talker.prototype._converse = function() {
        var follow_target, me, target;
        if (this.conversation_partner) {
          this.conversation_timer += 1;
          target = new Vector(this.conversation_partner.pos[0], this.conversation_partner.pos[1], 0);
          me = new Vector(this.pos[0], this.pos[1], 0);
          this.vector = Vector.lerp(this.vector, target.subtract(me), .001);
        }
        if (this.conversation_timer > 150) {
          if (Math.random() < .5 && !this.follow_target) {
            follow_target = this.conversation_partner;
            follow_target.follow_target = this;
            follow_target.state = 'follow';
            follow_target.follow_timer = 800;
            this.say('follow', follow_target.nombre);
            this.conversation_partner = false;
            this.conversation_timer = 0;
            this.state = 'wander';
            return;
          }
          this.conversation_partner = false;
          this.conversation_timer = 0;
          return this.state = 'idle';
        }
      };

      Talker.prototype.get_phrase = function(key) {
        var choice, set;
        if (window.phrases[key] != null) {
          set = window.phrases[key];
          choice = set[parseInt(Math.random() * set.length)];
          if (choice != null) {
            return choice;
          }
        }
      };

      Talker.prototype.say = function(key, arg1, arg2) {
        var guy, phrase, _i, _len, _ref, _results;
        if (arg1 == null) {
          arg1 = false;
        }
        if (arg2 == null) {
          arg2 = false;
        }
        this.debug.push(this.voice_que.length);
        phrase = this.get_phrase(key);
        if (phrase) {
          if (this.voice_que.length < 2) {
            if (key === 'help') {
              return this.voice_que.push([phrase.replace(/[$][1]/g, arg1), 0, 'emergency']);
            } else {
              this.voice_que.push([phrase.replace(/[$][1]/g, arg1), 0]);
              _ref = window.Entities.sentient;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                guy = _ref[_i];
                if (guy !== this && guy.hear) {
                  _results.push(guy.hear(this, key, arg1, arg2));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            }
          }
        }
      };

      Talker.prototype.say_verbose = function(str) {
        return this.voice_que = [[str, 0]].concat(this.voice_que);
      };

      Talker.prototype.hear = function(entity, key, arg1, arg2) {
        if (arg1 == null) {
          arg1 = false;
        }
        if (arg2 == null) {
          arg2 = false;
        }
        return this.hear_que.push([entity, key, arg1, arg2]);
      };

      Talker.prototype._process = function() {
        var arg1, arg2, blocked, entity, key, mem, talk, _i, _j, _len, _len1, _ref, _ref1, _results;
        _ref = this.hear_que;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          talk = _ref[_i];
          entity = talk[0];
          key = talk[1];
          arg1 = talk[2];
          arg2 = talk[3];
          if (!this.needs) {
            this.needs = [];
          }
          blocked = [];
          if (key === 'forget') {
            if (arg1 && arg2) {
              this.forget(arg1, arg2);
            }
          }
          if (key === 'need') {
            if (arg1) {
              if (__indexOf.call(this.needs, arg1) < 0) {
                this.needs.push(arg1);
              }
            }
          }
          if (key === 'location') {
            if (arg1) {
              if (!this.memory.objects[arg1]) {
                this.memory.objects[arg1] = [arg2];
                blocked.push(arg1);
              }
              _ref1 = this.memory.objects[arg1];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                mem = _ref1[_j];
                if (!(arg2[0] === mem[0] && arg2[1] === mem[1])) {
                  console.log('learned a location');
                  this.memory.objects[arg1] = this.memory.objects[arg1].slice(-10, this.memory.objects[arg1].length);
                  this.memory.objects[arg1].push(arg2);
                  blocked.push(arg1);
                }
              }
            }
          }
          if (key === 'greet') {
            if (arg1 && arg1 === this.nombre) {
              this.conversation_partner = entity;
              this.state_que = [];
              this.state = 'converse';
              this.say('greet', entity.nombre);
            }
          }
          /*
                  for need in @needs
                    if need not in blocked
                      if @memory.objects[need] and @memory.objects[need].length > 0
                          for mem in @memory.objects[need]
                            if mem and mem.length
                              r = window.Map.get('objects', mem[0], mem[1])
                              found = false
                              if r and r.length > 0
                                for obj in r
                                  if obj.nombre is need
                                    found = true
                                    @say 'location', need, @memory.objects[need][0]
                                    @needs.remove need
                                    @hear_que = []
                                    return
                                  else
                                    @forget need, mem
          */

          _results.push(this.hear_que = []);
        }
        return _results;
      };

      return Talker;

    })(Walker);
    Colonist = (function(_super) {

      __extends(Colonist, _super);

      function Colonist() {
        return Colonist.__super__.constructor.apply(this, arguments);
      }

      Colonist.prototype.setup = function() {
        this.pocket = [];
        this.suit = false;
        this.oxygen = 1200;
        this.max_oxygen = this.oxygen;
        this.want = false;
        this.job = false;
        this.state = 'idle';
        this.init_voice();
        return this.walk_frame = 0;
      };

      Colonist.prototype.update = function(delta) {
        var len, tile, w;
        if (this.vvv) {
          len = this.vvv.length();
          if (len > .2) {
            this.walk_frame += len * .25;
            if (this.walk_frame > 12) {
              this.walk_frame = 0;
            }
          }
        }
        if (this.oxygen != null) {
          tile = window.Map.get('tiles', this.tile_pos[0], this.tile_pos[1]);
          if (tile && tile !== 0) {
            this.oxygen += 5;
          }
          if (this.oxygen > this.max_oxygen) {
            this.oxygen = this.max_oxygen;
          }
          this.oxygen -= 1;
          if (this.oxygen < this.max_oxygen * .9) {
            window.Draw.use_layer('view');
            w = 32 * (this.oxygen / this.max_oxygen);
            window.Draw.draw_box(16 + this.pos[0] - w * .5, this.pos[1] + 30, w, 5, {
              fillStyle: 'red',
              strokeStyle: 'rgba(' + 32 - w + ',' + w + ',' + w + ',.4)',
              lineWidth: 0
            });
          }
          if (this.oxygen < 0) {
            this.die();
            return;
          }
        }
        if (this.follow_target) {
          this.debug.push(this.nombre + ' / ' + this.follow_target.nombre);
          this.follow_timer -= 1;
          if (this.follow_timer <= 0) {
            this.follow_target = false;
            return this.follow_timer = 150;
          }
        }
      };

      Colonist.prototype.draw_sprite = function() {
        var offset, rotation;
        offset = [parseInt(this.walk_frame) % 4, parseInt(parseInt(this.walk_frame) / 4)];
        rotation = false;
        if (this.vector && this.rotate_sprite) {
          rotation = Math.atan2(this.vector.y, this.vector.x);
          rotation += Math.PI / 2;
        }
        if (this.footprint_img) {
          if (this.draw_prints) {
            this.draw_prints = 0;
            window.Draw.use_layer('background');
            window.Draw.image(this.footprint_img, this.pos[0], this.pos[1], 32, 32, rotation);
          }
        }
        window.Draw.use_layer('entities');
        return window.Draw.sub_image(this.image, this.pos[0] + this.sprite_offset[0], this.pos[1] + this.sprite_offset[0], this.sprite_size, this.sprite_size, this.sprite_size, offset, rotation);
      };

      Colonist.prototype.die = function() {
        var corpse;
        if (this.suit) {
          corpse = new window.Entities.classes.Thing('a corpse', 'suitcorpse', this.pos);
        } else {
          corpse = new window.Entities.classes.Thing('a corpse', 'corpse', this.pos);
        }
        corpse.sprite_size = 48;
        corpse.sprite_offset = [0, 0];
        return this.destroy();
      };

      Colonist.prototype.forget = function(nombre, pos) {
        var loc, _i, _len, _ref;
        if (this.memory.objects[nombre]) {
          _ref = this.memory.objects[nombre];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            loc = _ref[_i];
            if (loc[0] === pos[0] && loc[1] === pos[1]) {
              this.memory.objects[nombre].remove(loc);
              return true;
            }
          }
        }
      };

      Colonist.prototype.drop = function(type) {
        var obj, _i, _len, _ref;
        console.log('drop', type);
        _ref = this.pocket;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obj = _ref[_i];
          if (obj.nombre === type) {
            obj.pos = [this.pos[0], this.pos[1]];
            obj.pos_to_tile_pos();
            obj.attach_to_map();
            this.pocket.remove(obj);
            if (obj.claimed) {
              obj.claimed = false;
            }
            if (this.claim) {
              this.claim = false;
            }
            return obj;
          }
        }
        return false;
      };

      Colonist.prototype._idle = function() {
        var use;
        this.mood = 'busy';
        if ((this.state_que != null) && this.state_que.length > 0) {
          use = this.state_que[0];
          this.state_que = this.state_que.slice(1, this.state_que.length);
          this.state = use;
          return;
        }
        if (!this.suit) {
          this.want = 'suit';
          this.job = 'find_suit';
          this.state_que.push('find_object');
          this.state_que.push('pickup');
          this.state_que.push('wear_suit');
          return;
        }
        if (this.oxygen < this.max_oxygen * .9) {
          if (this.oxygen < 260) {
            if (this.job) {
              this.state = 'job_fail';
              return;
            }
            this.state = 'asphyxiation';
            return;
          }
          if (this.oxygen < this.max_oxygen * .8) {
            if (this.job) {
              this.state = 'job_fail';
              return;
            }
            this.want = 'airtanks';
            this.state_que = ['find_object', 'use_object', 'job_complete'];
            this.job = 'refill_oxygen';
            return;
          }
        }
        if (this.follow_target && (this.follow_timer != null) && this.follow_timer > 0) {
          this.state = 'follow';
          return;
        }
        this.mood = 'bored';
        return this.state = 'work';
      };

      Colonist.prototype._refill_find_suit_fail = function() {
        this.say('need', 'suit');
        return this.state = 'wander_inside';
      };

      Colonist.prototype._refill_oxygen_job_fail = function() {
        if (this.claim) {
          this.claim.claimed = false;
          this.claim = false;
        }
        return this.state = 'work';
      };

      Colonist.prototype._refill_oxygen_job_complete = function() {
        if (this.claim) {
          this.claim.claimed = false;
          this.claim = false;
        }
        return this.state = 'work';
      };

      Colonist.prototype._follow = function() {
        if (!(this.follow_timer != null)) {
          this.follow_timer = 150;
        }
        if (this.follow_target) {
          return this.path_to(this.follow_target.tile_pos);
        }
      };

      Colonist.prototype._asphyxiation = function() {
        this.say('help');
        return this.state = 'wander_inside';
      };

      Colonist.prototype._use_object = function() {
        var found, obj, r, _i, _len;
        r = window.Map.get('objects', this.tile_pos[0], this.tile_pos[1]);
        found = false;
        if (r && r.length > 0) {
          for (_i = 0, _len = r.length; _i < _len; _i++) {
            obj = r[_i];
            if (obj.nombre === this.want) {
              found = true;
              if (obj.use) {
                if (obj.use(this)) {
                  this.state = 'idle';
                  this.forget(this.want, this.tile_pos);
                  return;
                } else {
                  return;
                }
              }
            }
          }
          if (!found) {
            this.state = 'job_fail';
          }
        }
        return this.state = 'job_fail';
      };

      Colonist.prototype._find_object = function() {
        var found;
        if (this.want) {
          found = this.find_unclaimed_object(this.want);
          if (found) {
            this.que_add_first('moving');
            this._found_obj = this.want;
            this.state = 'idle';
            return;
          }
          /*
                  if @memory.objects[@want]? and @memory.objects[@want].length > 0
                    list = @memory.objects[@want]
                    if Math.random() < .33
                      list = list.sort()
                    if Math.random() < .33
                      list = list.reverse()
                    for loc in @memory.objects[@want]
                      if @path_to loc
          
                        @que_add_first 'moving'
                        @_found_obj = @want
                        @state = 'idle'
                        return
          */

          this.say('need', this.want);
          this.state = 'job_fail';
        }
        return this.state = 'idle';
      };

      Colonist.prototype._pickup = function() {
        var found, obj, r, _i, _len;
        r = window.Map.get('objects', this.tile_pos[0], this.tile_pos[1]);
        found = false;
        if (r && r.length > 0) {
          for (_i = 0, _len = r.length; _i < _len; _i++) {
            obj = r[_i];
            if (obj.nombre === this.want) {
              found = true;
              obj.detach_from_map();
              this.pocket.push(obj);
              obj.pos = this.pos;
              this.want = false;
              this.state = 'idle';
              return;
            }
          }
        }
        if (!found) {
          return this.state = 'job_fail';
        }
      };

      Colonist.prototype.clear_common_props = function() {
        this.want = false;
        if (this.claim) {
          this.claim.claimed = false;
          this.claim = false;
        }
        return this._found_obj = false;
      };

      Colonist.prototype._job_complete = function() {
        this.state = 'idle';
        if (this.job) {
          this.clear_common_props();
          this.state_que = [];
          this.state = 'wait';
          if (this['_' + this.job + '_job_complete']) {
            this['_' + this.job + '_job_complete']();
          }
          return this.job = false;
        }
      };

      Colonist.prototype._job_fail = function() {
        this.state = 'idle';
        if (this.job) {
          this.clear_common_props();
          this.state_que = [];
          this.state = 'wait';
          if (this['_' + this.job + '_job_fail']) {
            this['_' + this.job + '_job_fail']();
          } else {
            console.log("can't call ", '_' + this.job + '_job_fail');
          }
          return this.job = false;
        }
      };

      Colonist.prototype._wear_suit = function() {
        this.suit = true;
        this.oxygen = 6000;
        this.max_oxygen = 6000;
        this.image = 'suitwalk';
        return this.state = 'idle';
      };

      Colonist.prototype._work = function() {
        return this.state = 'break';
      };

      Colonist.prototype._break = function() {
        var guy, near, _i, _len, _ref;
        if (Math.random() < .7) {
          if (Math.random() < .5) {
            this.wander_dist = 20;
            return this.state = 'wander_inside';
          } else {
            this.wander_dist = 5;
            return this.state = 'wander';
          }
        } else {
          near = window.Entities.sentient_hash.get_within(this.pos, 80);
          if (near) {
            for (_i = 0, _len = near.length; _i < _len; _i++) {
              guy = near[_i];
              if (guy !== this) {
                if (((_ref = guy.state) === 'idle' || _ref === 'wait' || _ref === 'break') && (guy.mood != null) && guy.mood === 'bored') {
                  if (new Vector(guy.pos[0], guy.pos[1], 0).subtract(new Vector(this.pos[0], this.pos[1], 0)).length() < 32) {
                    if (!this.memory.entities[guy.nombre]) {
                      this.memory.entities[guy.nombre] = true;
                      this.say('greet', guy.nombre);
                      this.conversation_partner = guy;
                      this.state = 'converse';
                      return;
                    } else {
                      this.say('sup', guy.nombre);
                      this.conversation_partner = guy;
                      this.state = 'converse';
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      };

      return Colonist;

    })(Talker);
    Engineer = (function(_super) {

      __extends(Engineer, _super);

      function Engineer() {
        return Engineer.__super__.constructor.apply(this, arguments);
      }

      Engineer.prototype._work = function() {
        var obj, obj_in_map, p, tile, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        if (this.remove_order) {
          if (this.n_tiles_away(this.tile_pos, this.remove_order.tile_pos, 2)) {
            this.remove_order.destroy();
            return this.remove_order = false;
          } else {

          }
        } else if (this.build_order) {
          if (this.n_tiles_away(this.tile_pos, [this.build_order.x, this.build_order.y], 2)) {
            this.build_order.build(this.delta_time * 3);
            if (this.build_order.built) {
              if (!this.build_order.is_wall()) {
                window.Map.set("pathfinding", this.x, this.y, 0);
              }
              console.log('tile built');
              return this.build_order = false;
            }
          } else {
            console.log('not close enough to build');
            window.Tiles.under_construction.push(this.build_order);
            return this.build_order = false;
          }
        } else {
          if (window.Tiles && window.Tiles.under_construction && window.Tiles.under_construction.length > 0) {
            tile = window.Tiles.under_construction[0];
            if (this.path_to([tile.x, tile.y])) {
              this.build_order = tile;
              window.Tiles.under_construction.remove(tile);
              this.state = 'moving';
            } else {
              obj_in_map = window.Map.get('objects', tile.x, tile.y);
              if (obj_in_map && obj_in_map.length) {
                for (_i = 0, _len = obj_in_map.length; _i < _len; _i++) {
                  obj = obj_in_map[_i];
                  if (obj.no_path) {
                    if (!obj.claimed) {
                      _ref = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                        p = _ref[_j];
                        if (this.path_to([p[0] + tile.x, p[1] + tile.y])) {
                          this.remove_order = obj;
                          this.state = 'moving';
                          obj.claimed = true;
                          return;
                        }
                      }
                    }
                    window.Tiles.under_construction.remove(tile);
                    window.Tiles.under_construction.push(tile);
                    this.state = 'wander';
                    return;
                  }
                }
              }
            }
            _ref1 = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              p = _ref1[_k];
              if (this.path_to([p[0] + tile.x, p[1] + tile.y])) {
                this.build_order = tile;
                window.Tiles.under_construction.remove(tile);
                this.state = 'moving';
                return;
              }
            }
          } else if (window.Placer.jobs.length > 0) {
            this.place_order = window.Placer.jobs.pop();
            this.want = this.place_order[0];
            this.job = 'place';
            this.say_verbose('Placing Object');
            this.state_que = ['find_object', 'pickup', 'place_carry'];
            return this.state = 'idle';
          } else {
            if (Math.random() < .3) {
              return this.state = 'inventory';
            } else {
              return this.state = 'break';
            }
          }
        }
      };

      Engineer.prototype._place_job_fail = function() {
        var dump, obj, _i, _j, _len, _len1, _ref;
        console.log('place fail');
        if (this.place_order) {
          window.Placer.jobs.push(this.place_order);
          dump = [];
          _ref = this.pocket;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            obj = _ref[_i];
            if (obj.nombre === this.place_order[0]) {
              dump.push(obj);
            }
          }
          for (_j = 0, _len1 = dump.length; _j < _len1; _j++) {
            obj = dump[_j];
            this.drop(obj.nombre);
          }
          if (this.pocket.length > 0) {
            this.drop(this.pocket[0].nombre);
          }
          this.place_order = false;
          return this.say('fail');
        }
      };

      Engineer.prototype._place_carry = function() {
        var obj, p, path, _i, _len, _ref;
        _ref = this.pocket;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          obj = _ref[_i];
          if (obj.nombre === this.place_order[0]) {
            obj.show();
          }
        }
        p = this.place_order[1];
        path = this.path_close_to([p[0], p[1]]);
        console.log('CARRY TO ', path);
        if (path) {
          this.path = path;
          this.state_que = ['place_install', 'job_complete'];
          return this.state = 'moving';
        } else {
          this.state_que = [];
          if (this.place_order) {
            return this.state = 'job_fail';
          }
        }
      };

      Engineer.prototype._place_install = function() {
        var dropped, g;
        if (this.place_order) {
          dropped = this.drop(this.place_order[0]);
          if (dropped) {
            g = this.place_order[1];
            dropped.pos = [g[0] * 32, g[1] * 32];
            if (dropped.place) {
              dropped.place();
            }
            this.state = 'job_complete';
            return;
          }
        }
        return this.state = 'job_fail';
      };

      Engineer.prototype._place_job_complete = function() {
        console.log('place_job_complete');
        window.Placer.job_done(this.place_order);
        return this.place_order = false;
      };

      Engineer.prototype._inventory = function() {
        var i, j, l, obj, objs, pos, _i, _j, _k, _len;
        for (i = _i = -3; _i <= 3; i = ++_i) {
          for (j = _j = -3; _j <= 3; j = ++_j) {
            objs = window.Map.get('objects', this.tile_pos[0] + i, this.tile_pos[1] + j);
            if (objs) {
              for (_k = 0, _len = objs.length; _k < _len; _k++) {
                obj = objs[_k];
                pos = [obj.tile_pos[0], obj.tile_pos[1]];
                if (this.memory.objects[obj.nombre]) {
                  l = this.memory.objects[obj.nombre];
                  l.push(pos);
                } else {
                  this.memory.objects[obj.nombre] = [pos];
                }
              }
            }
          }
        }
        return this.state = 'break';
      };

      Engineer.prototype._wander = function() {
        this.target = this.get_random_tile(this.wander_dist);
        return this.path_to(this.target);
      };

      Engineer.prototype._wander_inside = function() {
        var f, target;
        if (!(this.wander_inside_counter != null) || this.wander_inside_counter < 0) {
          this.wander_inside_counter = 20;
        }
        this.wander_inside_counter -= 1;
        target = this.get_random_tile(this.wander_dist);
        f = window.Map.get('tiles', target[0], target[1]);
        if (f && !f.is_wall() && f.built) {
          this.say_verbose('Going inside', f);
          this.target = target;
          this.path_to(this.target);
          this.wander_inside_counter = -1;
          return;
        }
        if (this.wander_inside_counter < 0) {
          return this.state = 'idle';
        }
      };

      Engineer.prototype._removing_object = function() {
        var x, y;
        x = parseInt(Math.random() * 2) - 1;
        y = parseInt(Math.random() * 2) - 1;
        x += this.remove_order.tile_pos[0];
        y += this.remove_order.tile_pos[1];
        return this.path_to([x, y]);
      };

      return Engineer;

    })(Colonist);
    window.Entities.classes.Walker = Walker;
    window.Entities.classes.Talker = Talker;
    window.Entities.classes.Colonist = Colonist;
    return window.Entities.classes.Engineer = Engineer;
  });

}).call(this);

// Generated by CoffeeScript 1.3.1
(function() {
  var AStar, AnimatedSearch, Annotations, Dijkstra, Greedy, Grid, GridDiagram, ImmediateNeighbors, InteractiveGrid, JumpPointSuccessors, Map, Node, PathFinder, log,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  $(function() {
    window.diagrams = $('.grid-diagram').map(function(i, el) {
      return new GridDiagram($(el), 24);
    });
    return window.interactive = $('.interactive-container').map(function(i, el) {
      return new InteractiveGrid($(el), 24);
    });
  });

  InteractiveGrid = (function() {

    InteractiveGrid.name = 'InteractiveGrid';

    function InteractiveGrid(element, size) {
      var $el, $grid, goal, height, points, start, width, x, y, _i, _j, _ref,
        _this = this;
      if (size == null) {
        size = 20;
      }
      this.update = __bind(this.update, this);

      $el = $(element);
      $grid = $el.find('.interactive-grid');
      $grid.html("");
      _ref = _.map($grid.data("size").split(","), function(n) {
        return parseInt(n);
      }), width = _ref[0], height = _ref[1];
      points = [];
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
        for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
          points.push([x, y, 'clear']);
        }
      }
      y = Math.floor(height / 2);
      start = [2, y];
      goal = [width - 3, y];
      this.grid = new Grid($grid, width, height, size);
      this.map = new Map(this.grid, points, start, goal, true);
      this.annotations = new Annotations(this.grid);
      this.map.draw();
      $el.find('button.start').click(function() {
        var jps;
        $el.find('button.start').hide();
        $el.find('button.stop').show();
        $el.find('button.reset').hide();
        jps = $el.find('input[type=checkbox]').is(':checked');
        _this.anim = new AnimatedSearch(_this.map, _this.annotations, jps, 100);
        return _this.anim.run(function() {
          $el.find('button.stop').hide();
          $el.find('button.start').show();
          return $el.find('button.reset').show();
        });
      });
      $el.find('button.stop').click(function() {
        $el.find('button.stop').hide();
        $el.find('button.start').show();
        $el.find('button.reset').show();
        if (_this.anim) {
          return _this.anim.finished = true;
        }
      });
      $el.find('button.reset').click(function() {
        $el.find('button.reset').hide();
        _this.annotations.reset();
        return _this.map.editable = true;
      });
    }

    InteractiveGrid.prototype.update = function(state) {
      var closed, current, goal, open, paths, previous, start;
      open = state.open;
      closed = state.closed;
      paths = [];
      previous = [];
      start = this.map.start();
      goal = this.map.goal();
      current = state.current;
      return this.annotations.update(open, closed, paths, previous, start, goal, current);
    };

    return InteractiveGrid;

  })();

  AnimatedSearch = (function() {

    AnimatedSearch.name = 'AnimatedSearch';

    function AnimatedSearch(map, annotations, jps, delay) {
      var neighborStrategy;
      this.map = map;
      this.annotations = annotations;
      if (jps == null) {
        jps = false;
      }
      this.delay = delay != null ? delay : 200;
      this.tick = __bind(this.tick, this);

      this.run = __bind(this.run, this);

      this.finished = false;
      neighborStrategy = jps ? JumpPointSuccessors : ImmediateNeighbors;
      this.path = new PathFinder(this.map, neighborStrategy);
    }

    AnimatedSearch.prototype.run = function(callback) {
      this.callback = callback;
      this.map.editable = false;
      this.annotations.reset();
      return setTimeout(this.tick, this.delay);
    };

    AnimatedSearch.prototype.tick = function() {
      var state;
      if (this.finished) {
        if (this.callback != null) {
          this.callback();
        }
        return;
      }
      this.finished = this.path.step();
      state = this.path.state();
      this.annotations.update(state.open, state.closed, state.paths, state.previous, this.map.start(), this.map.goal(), state.current);
      return setTimeout(this.tick, this.delay);
    };

    return AnimatedSearch;

  })();

  GridDiagram = (function() {

    GridDiagram.name = 'GridDiagram';

    function GridDiagram(element, size) {
      var $el, blocked, closed, current, forced, goal, height, open, paths, points, previous, start, width, x, y, _i, _j, _ref;
      if (size == null) {
        size = 20;
      }
      this.pathsToPoints = __bind(this.pathsToPoints, this);

      $el = $(element);
      $el.html("");
      _ref = _.map($el.data("size").split(","), function(n) {
        return parseInt(n);
      }), width = _ref[0], height = _ref[1];
      this.grid = new Grid($el, width, height, size);
      blocked = this.expandList($el.data('blocked'));
      points = [];
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
        for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
          if (_.indexOf(blocked, x + y * width) === -1) {
            points.push([x, y, 'clear']);
          } else {
            points.push([x, y, 'blocked']);
          }
        }
      }
      paths = [];
      if ($el.data('paths')) {
        paths = this.pathsToPoints($el.data('paths'));
      }
      previous = [];
      if ($el.data('previous')) {
        previous = this.pathsToPoints($el.data('previous'));
      }
      open = [];
      if ($el.data('open') != null) {
        open = _.map(this.expandList($el.data('open')), this.grid.fromOffset);
      }
      closed = [];
      if ($el.data('closed') != null) {
        closed = _.map(this.expandList($el.data('closed')), this.grid.fromOffset);
      }
      forced = [];
      if ($el.data('forced') != null) {
        forced = _.map(this.expandList($el.data('forced')), this.grid.fromOffset);
      }
      start = $el.data('start') != null ? this.grid.fromOffset(parseInt($el.data('start'))) : void 0;
      goal = $el.data('goal') != null ? this.grid.fromOffset(parseInt($el.data('goal'))) : void 0;
      current = $el.data('current') != null ? this.grid.fromOffset(parseInt($el.data('current'))) : void 0;
      this.map = new Map(this.grid, points, start, goal);
      this.annotations = new Annotations(this.grid);
      $el.show();
      this.map.draw();
      this.annotations.update(open, closed, paths, previous, start, goal, current, forced);
    }

    GridDiagram.prototype.expandList = function(list) {
      var parts;
      parts = _.map(("" + list).split(","), function(part) {
        var end, start, x, _ref;
        _ref = part.split("-"), start = _ref[0], end = _ref[1];
        if (end) {
          return x = _.range(parseInt(start), parseInt(end) + 1);
        } else {
          return parseInt(start);
        }
      });
      return _.flatten(parts);
    };

    GridDiagram.prototype.pathsToPoints = function(list) {
      var _this = this;
      return _.map(list.split(","), function(pair) {
        return _.map(pair.split("-"), _.compose(_this.grid.fromOffset, function(s) {
          return parseInt(s);
        }));
      });
    };

    return GridDiagram;

  })();

  Grid = (function() {

    Grid.name = 'Grid';

    function Grid(el, width, height, size) {
      this.width = width;
      this.height = height;
      this.size = size;
      this.appendSVGElements = __bind(this.appendSVGElements, this);

      this.normalizedCoords = __bind(this.normalizedCoords, this);

      this.fromOffset = __bind(this.fromOffset, this);

      this.offset = __bind(this.offset, this);

      this.el = el.get(0);
      this.container = d3.select(this.el);
      this.appendSVGElements();
      this.mapSelection = this.container.select('.map');
      this.annotationSelection = this.container.select('.annotations');
    }

    Grid.prototype.offset = function(x, y) {
      if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
        return x + y * this.width;
      }
    };

    Grid.prototype.fromOffset = function(offset) {
      return [offset % this.width, Math.floor(offset / this.width)];
    };

    Grid.prototype.normalizedCoords = function(coords) {
      var x, y;
      x = coords[0], y = coords[1];
      x = Math.floor(x / this.size);
      y = Math.floor(y / this.size);
      if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
        return [x, y];
      } else {
        return null;
      }
    };

    Grid.prototype.appendSVGElements = function() {
      var svg, translate;
      svg = this.container.append('svg:svg');
      svg.attr('width', this.width * this.size + 2);
      svg.attr('height', this.height * this.size + 2);
      translate = svg.append('svg:g').attr('transform', "translate(1," + (this.height * this.size + 1) + ")");
      translate.append('svg:g').attr('transform', 'scale(1,-1)').attr('class', 'map');
      translate.append('svg:g').attr('transform', 'scale(1,-1)').attr('class', 'annotations');
      return this.mapElement = $(this.el).find('.map').get(0);
    };

    return Grid;

  })();

  Map = (function() {

    Map.name = 'Map';

    function Map(grid, points, start, goal, interactive) {
      this.grid = grid;
      this.points = points;
      if (interactive == null) {
        interactive = false;
      }
      this.updateNode = __bind(this.updateNode, this);

      this.mouseover = __bind(this.mouseover, this);

      this.mouseup = __bind(this.mouseup, this);

      this.mousedown = __bind(this.mousedown, this);

      this.draw = __bind(this.draw, this);

      this.goal = __bind(this.goal, this);

      this.start = __bind(this.start, this);

      this.isClear = __bind(this.isClear, this);

      this.reachable = __bind(this.reachable, this);

      this.updatePoint = __bind(this.updatePoint, this);

      if (start) {
        this.updatePoint(start, 'start');
      }
      if (goal) {
        this.updatePoint(goal, 'goal');
      }
      this.editable = interactive;
      this.drag = null;
      $('body').on('mouseup', this.mouseup);
      $('body').on('touchend', this.mouseup);
      $('body').on('touchcancel', this.mouseup);
    }

    Map.prototype.updatePoint = function(point, type) {
      var offset, x, y;
      x = point[0], y = point[1];
      offset = this.grid.offset(x, y);
      return this.points[offset][2] = type;
    };

    Map.prototype.reachable = function(from, to) {
      var dx, dy, x1, x2, y1, y2;
      x1 = from[0], y1 = from[1];
      x2 = to[0], y2 = to[1];
      dx = x2 - x1;
      dy = y2 - y1;
      return this.isClear(to) && ((dx === 0 || dy === 0) || (this.isClear([x1, y2]) || this.isClear([x2, y1])));
    };

    Map.prototype.isClear = function(_arg) {
      var offset, x, y;
      x = _arg[0], y = _arg[1];
      offset = this.grid.offset(x, y);
      if (offset != null) {
        return this.points[offset][2] !== 'blocked';
      }
    };

    Map.prototype.start = function() {
      var kind, x, y, _i, _len, _ref, _ref1;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1], kind = _ref1[2];
        if (kind === 'start') {
          return [x, y];
        }
      }
    };

    Map.prototype.goal = function() {
      var kind, x, y, _i, _len, _ref, _ref1;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1], kind = _ref1[2];
        if (kind === 'goal') {
          return [x, y];
        }
      }
    };

    Map.prototype.draw = function() {
      var squares,
        _this = this;
      squares = this.grid.mapSelection.selectAll('rect').data(this.points, function(d, i) {
        return [d[0], d[1]];
      });
      squares.enter().append('rect').attr('x', function(d, i) {
        return _this.grid.size * d[0];
      }).attr('y', function(d, i) {
        return _this.grid.size * d[1];
      }).attr('width', this.grid.size).attr('height', this.grid.size).on('mousedown', this.mousedown).on('touchstart', this.mousedown).on('mouseover', this.mouseover).on('touchmove', this.mouseover);
      return squares.attr('class', function(d, i) {
        return d[2];
      });
    };

    Map.prototype.mousedown = function(d, i) {
      var square;
      if (!this.editable) {
        return;
      }
      square = d3.select(d3.event.target);
      this.drag = square.attr('class');
      this.mouseover(d, i);
      return d3.event.preventDefault();
    };

    Map.prototype.mouseup = function() {
      var goal, start;
      if (!this.editable) {
        return;
      }
      switch (this.drag) {
        case 'start':
          start = this.grid.mapSelection.selectAll('rect.start');
          this.updateNode(start, 'start');
          break;
        case 'goal':
          goal = this.grid.mapSelection.selectAll('rect.goal');
          this.updateNode(goal, 'goal');
      }
      return this.drag = null;
    };

    Map.prototype.mouseover = function(d, i) {
      var before, coords, square, touches;
      if (!(this.editable && this.drag)) {
        return;
      }
      touches = d3.event.changedTouches;
      coords = touches != null ? d3.touches(this.grid.mapElement, touches)[0] : d3.mouse(this.grid.mapElement);
      if (!(coords = this.grid.normalizedCoords(coords))) {
        return;
      }
      square = this.grid.mapSelection.selectAll('rect').filter(function(d, i) {
        var x, y, _;
        x = d[0], y = d[1], _ = d[2];
        return x === coords[0] && y === coords[1];
      });
      switch (this.drag) {
        case 'clear':
          if (square.classed('clear')) {
            this.updateNode(square, 'blocked');
          }
          break;
        case 'blocked':
          if (square.classed('blocked')) {
            this.updateNode(square, 'clear');
          }
          break;
        case 'start':
          if (!square.classed('goal')) {
            before = this.grid.mapSelection.selectAll('rect.start');
            before.classed('start', false);
            if (before.attr('class') === "") {
              this.updateNode(before, 'clear');
            }
            square.classed('start', true);
          }
          break;
        case 'goal':
          if (!square.classed('start')) {
            before = this.grid.mapSelection.selectAll('rect.goal');
            before.classed('goal', false);
            if (before.attr('class') === "") {
              this.updateNode(before, 'clear');
            }
            square.classed('goal', true);
          }
      }
      return d3.event.preventDefault();
    };

    Map.prototype.updateNode = function(selection, type) {
      var x, y, _, _ref;
      _ref = selection.datum(), x = _ref[0], y = _ref[1], _ = _ref[2];
      this.updatePoint([x, y], type);
      return this.draw();
    };

    return Map;

  })();

  Annotations = (function() {

    Annotations.name = 'Annotations';

    function Annotations(grid) {
      this.grid = grid;
      this.defineArrowhead = __bind(this.defineArrowhead, this);

      this.defineArrowheads = __bind(this.defineArrowheads, this);

      this.lineSegment = __bind(this.lineSegment, this);

      this.drawSquares = __bind(this.drawSquares, this);

      this.drawPaths = __bind(this.drawPaths, this);

      this.draw = __bind(this.draw, this);

      this.reset = __bind(this.reset, this);

      this.update = __bind(this.update, this);

      this.defineArrowheads();
    }

    Annotations.prototype.update = function(open, closed, paths, previous, start, goal, current, forced) {
      this.start = start;
      this.goal = goal;
      this.current = current;
      this.open = open || [];
      this.closed = closed || [];
      this.paths = paths || [];
      this.previous = previous || [];
      this.forced = forced || [];
      return this.draw();
    };

    Annotations.prototype.reset = function() {
      this.open = this.closed = this.paths = this.previous = this.forced = [];
      this.start = this.goal = this.current = null;
      return this.draw();
    };

    Annotations.prototype.draw = function() {
      this.drawSquares();
      return this.drawPaths();
    };

    Annotations.prototype.drawPaths = function() {
      var data, pair, paths, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      data = [];
      _ref = this.paths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pair = _ref[_i];
        data.push([pair, 'current']);
      }
      _ref1 = this.previous;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pair = _ref1[_j];
        data.push([pair, 'previous']);
      }
      paths = this.grid.annotationSelection.selectAll("line").data(data, function(d, i) {
        return JSON.stringify(d[0]);
      });
      paths.enter().append('line').attr('x1', function(d, i) {
        return _this.lineSegment(d)[0];
      }).attr('y1', function(d, i) {
        return _this.lineSegment(d)[1];
      }).attr('x2', function(d, i) {
        return _this.lineSegment(d)[2];
      }).attr('y2', function(d, i) {
        return _this.lineSegment(d)[3];
      });
      paths.attr('class', function(d, i) {
        return d[1];
      }).attr('marker-end', function(d, i) {
        return "url(#arrowhead-" + d[1] + ")";
      });
      return paths.exit().remove();
    };

    Annotations.prototype.drawSquares = function() {
      var points, squares, x, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
        _this = this;
      points = [];
      if (this.current) {
        points.push([this.current[0], this.current[1], 'current']);
      }
      if (this.start) {
        points.push([this.start[0], this.start[1], 'start']);
      }
      if (this.goal) {
        points.push([this.goal[0], this.goal[1], 'goal']);
      }
      _ref = this.forced;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
        points.push([x, y, 'forced']);
      }
      _ref2 = this.open;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        _ref3 = _ref2[_j], x = _ref3[0], y = _ref3[1];
        points.push([x, y, 'open']);
      }
      _ref4 = this.closed;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        _ref5 = _ref4[_k], x = _ref5[0], y = _ref5[1];
        points.push([x, y, 'closed']);
      }
      squares = this.grid.annotationSelection.selectAll("rect").data(points, function(d, i) {
        return JSON.stringify([d[0], d[1]]);
      });
      squares.enter().append('rect').attr('x', function(d, i) {
        return _this.grid.size * d[0];
      }).attr('y', function(d, i) {
        return _this.grid.size * d[1];
      }).attr('width', this.grid.size).attr('height', this.grid.size);
      squares.attr('class', function(d, i) {
        return d[2];
      });
      return squares.exit().remove();
    };

    Annotations.prototype.lineSegment = function(d) {
      var a, dx, dy, x1, x2, y1, y2, _ref, _ref1, _ref2;
      _ref = d[0], (_ref1 = _ref[0], x1 = _ref1[0], y1 = _ref1[1]), (_ref2 = _ref[1], x2 = _ref2[0], y2 = _ref2[1]);
      dx = x2 - x1;
      dy = y2 - y1;
      a = Math.sqrt((dx * dx) + (dy * dy));
      x1 += 0.2 * (a === 0 ? 0 : dx / a);
      y1 += 0.2 * (a === 0 ? 0 : dy / a);
      x2 -= 0.2 * (a === 0 ? 0 : dx / a);
      y2 -= 0.2 * (a === 0 ? 0 : dy / a);
      return [x1 * this.grid.size + this.grid.size / 2, y1 * this.grid.size + this.grid.size / 2, x2 * this.grid.size + this.grid.size / 2, y2 * this.grid.size + this.grid.size / 2];
    };

    Annotations.prototype.defineArrowheads = function() {
      var defs;
      defs = this.grid.annotationSelection.append('svg:defs');
      this.defineArrowhead(defs, 'current');
      return this.defineArrowhead(defs, 'previous');
    };

    Annotations.prototype.defineArrowhead = function(defs, kind) {
      return defs.append('marker').attr('id', "arrowhead-" + kind).attr('orient', 'auto').attr('viewBox', '0 0 10 10').attr('refX', 6).attr('refY', 5).append('polyline').attr('points', '0,0 10,5 0,10 1,5');
    };

    return Annotations;

  })();

  ImmediateNeighbors = (function() {

    ImmediateNeighbors.name = 'ImmediateNeighbors';

    function ImmediateNeighbors(map) {
      this.map = map;
      this.of = __bind(this.of, this);

      this.successors = __bind(this.successors, this);

      this.immediateNeighbors = __bind(this.immediateNeighbors, this);

    }

    ImmediateNeighbors.prototype.immediateNeighbors = function(node) {
      var dx, dy, ns, p, x, y, _i, _j, _ref;
      ns = [];
      _ref = node.pos, x = _ref[0], y = _ref[1];
      for (dx = _i = -1; _i <= 1; dx = ++_i) {
        for (dy = _j = -1; _j <= 1; dy = ++_j) {
          if (dx === 0 && dy === 0) {
            continue;
          }
          p = [x + dx, y + dy];
          if (this.map.reachable([x, y], p)) {
            ns.push(new Node(p));
          }
        }
      }
      return ns;
    };

    ImmediateNeighbors.prototype.successors = function(node) {
      return this.immediateNeighbors(node);
    };

    ImmediateNeighbors.prototype.of = function(node) {
      return this.successors(node);
    };

    return ImmediateNeighbors;

  })();

  JumpPointSuccessors = (function(_super) {

    __extends(JumpPointSuccessors, _super);

    JumpPointSuccessors.name = 'JumpPointSuccessors';

    function JumpPointSuccessors() {
      this.neighbors = __bind(this.neighbors, this);

      this.forcedNeighbors = __bind(this.forcedNeighbors, this);

      this.jump = __bind(this.jump, this);

      this.successors = __bind(this.successors, this);
      return JumpPointSuccessors.__super__.constructor.apply(this, arguments);
    }

    JumpPointSuccessors.prototype.successors = function(node) {
      var jumps, ns,
        _this = this;
      ns = this.neighbors(node);
      jumps = _.map(ns, function(n) {
        var dx, dy, px, py, x, y, _ref, _ref1;
        _ref = node.pos, px = _ref[0], py = _ref[1];
        _ref1 = n.pos, x = _ref1[0], y = _ref1[1];
        dx = x - px;
        dy = y - py;
        return _this.jump(node.pos, [dx, dy]);
      });
      jumps = _.filter(jumps, function(i) {
        return i != null;
      });
      return _.map(jumps, function(j) {
        return new Node(j);
      });
    };

    JumpPointSuccessors.prototype.jump = function(from, direction) {
      var dx, dy, next, nx, ny, prev, x, y;
      x = from[0], y = from[1];
      dx = direction[0], dy = direction[1];
      prev = from;
      next = [x + dx, y + dy];
      while (this.map.reachable(prev, next)) {
        if (_.isEqual(next, this.map.goal())) {
          return next;
        }
        if (this.forcedNeighbors(next, [dx, dy]).length) {
          return next;
        }
        if (dx !== 0 && dy !== 0 && (this.jump(next, [dx, 0]) || this.jump(next, [0, dy]))) {
          return next;
        }
        nx = next[0], ny = next[1];
        prev = next;
        next = [nx + dx, ny + dy];
      }
      return null;
    };

    JumpPointSuccessors.prototype.forcedNeighbors = function(from, direction) {
      var dx, dy, forced, x, y,
        _this = this;
      x = from[0], y = from[1];
      dx = direction[0], dy = direction[1];
      forced = [];
      if (dy === 0) {
        if (!this.map.isClear([x, y - 1])) {
          forced.push([x + dx, y - 1]);
        }
        if (!this.map.isClear([x, y + 1])) {
          forced.push([x + dx, y + 1]);
        }
      } else if (dx === 0) {
        if (!this.map.isClear([x - 1, y])) {
          forced.push([x - 1, y + dy]);
        }
        if (!this.map.isClear([x + 1, y])) {
          forced.push([x + 1, y + dy]);
        }
      } else {
        if (!this.map.isClear([x - dx, y])) {
          forced.push([x - dx, y + dy]);
        }
        if (!this.map.isClear([x, y - dy])) {
          forced.push([x + dx, y - dy]);
        }
      }
      return _.filter(forced, function(n) {
        return _this.map.reachable(from, n);
      });
    };

    JumpPointSuccessors.prototype.neighbors = function(node) {
      var dx, dy, neighbors, ns, px, py, reachable, x, y, _ref, _ref1,
        _this = this;
      if (node.parent) {
        _ref = node.pos, x = _ref[0], y = _ref[1];
        _ref1 = node.parent.pos, px = _ref1[0], py = _ref1[1];
        dx = x - px;
        dx = dx > 1 ? 1 : dx < -1 ? -1 : dx;
        dy = y - py;
        dy = dy > 1 ? 1 : dy < -1 ? -1 : dy;
        neighbors = dy === 0 ? [[x + dx, y]] : dx === 0 ? [[x, y + dy]] : [[x, y + dy], [x + dx, y], [x + dx, y + dy]];
        reachable = _.filter(neighbors, function(n) {
          return _this.map.reachable(node.pos, n);
        });
        ns = _.union(reachable, this.forcedNeighbors([x, y], [dx, dy]));
        return _.map(ns, function(n) {
          return new Node(n);
        });
      } else {
        return this.immediateNeighbors(node);
      }
    };

    return JumpPointSuccessors;

  })(ImmediateNeighbors);

  Node = (function() {

    Node.name = 'Node';

    function Node(pos) {
      this.pos = pos;
      this.eq = __bind(this.eq, this);

      this.key = JSON.stringify(this.pos);
      this.g = this.h = 0;
    }

    Node.prototype.eq = function(other) {
      return this.key === other.key;
    };

    return Node;

  })();

  PathFinder = (function() {

    PathFinder.name = 'PathFinder';

    function PathFinder(map, neighborStrategy, costStrategy) {
      var start;
      if (neighborStrategy == null) {
        neighborStrategy = ImmediateNeighbors;
      }
      this.costStrategy = costStrategy != null ? costStrategy : AStar;
      this.step = __bind(this.step, this);

      this.state = __bind(this.state, this);

      this.open = {};
      this.closed = {};
      this.path = null;
      this.successors = new neighborStrategy(map);
      start = map.start();
      this.start = new Node(map.start());
      this.goal = new Node(map.goal());
      this.start.g = 0;
      this.start.h = this.chebyshev(this.start, this.goal);
      this.open[this.start.key] = this.start;
    }

    PathFinder.prototype.distance = function(from, to) {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = from.pos, x1 = _ref[0], y1 = _ref[1];
      _ref1 = to.pos, x2 = _ref1[0], y2 = _ref1[1];
      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    };

    PathFinder.prototype.chebyshev = function(from, to) {
      var dx, dy, x1, x2, y1, y2, _ref, _ref1;
      _ref = from.pos, x1 = _ref[0], y1 = _ref[1];
      _ref1 = to.pos, x2 = _ref1[0], y2 = _ref1[1];
      dx = Math.abs(x2 - x1);
      dy = Math.abs(y2 - y1);
      return dx + dy + (Math.sqrt(2) - 2) * Math.min(dx, dy);
    };

    PathFinder.prototype.state = function() {
      var finalPath, nodes, paths, withParents,
        _this = this;
      nodes = _.flatten([_.values(this.open), _.values(this.closed)]);
      withParents = _.select(nodes, function(e) {
        return e.parent != null;
      });
      paths = _.map(withParents, function(e) {
        return [e.parent.pos, e.pos];
      });
      finalPath = [];
      if (this.path) {
        _.each(this.path, function(e, i, l) {
          var next;
          if (next = l[i + 1]) {
            return finalPath.push([e, next]);
          }
        });
      }
      return {
        open: _.pluck(_.values(this.open), "pos"),
        closed: _.pluck(_.values(this.closed), "pos"),
        current: !this.path && this.current && this.current.pos,
        paths: finalPath,
        previous: paths
      };
    };

    PathFinder.prototype.step = function() {
      var current, existing, neighbor, newG, path, _i, _len, _ref,
        _this = this;
      if (this.path) {
        return true;
      }
      this.current = current = _.first(_.sortBy(_.values(this.open), function(n) {
        return _this.costStrategy(n.g, n.h);
      }));
      if (!current) {
        return true;
      }
      if (current.eq(this.goal)) {
        path = [this.goal.pos];
        while (current.parent != null) {
          current = current.parent;
          path.unshift(current.pos);
        }
        this.path = path;
        return true;
      }
      delete this.open[current.key];
      this.closed[current.key] = current;
      _ref = this.successors.of(current);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        neighbor = _ref[_i];
        newG = current.g + this.distance(current, neighbor);
        if (existing = this.open[neighbor.key] || (existing = this.closed[neighbor.key])) {
          if (newG >= existing.g) {
            continue;
          }
          existing.parent = current;
          existing.g = newG;
        } else {
          neighbor.parent = current;
          neighbor.g = newG;
          neighbor.h = this.chebyshev(neighbor, this.goal);
          this.open[neighbor.key] = neighbor;
        }
      }
      return null;
    };

    return PathFinder;

  })();

  Dijkstra = function(g, h) {
    return g;
  };

  Greedy = function(g, h) {
    return h;
  };

  AStar = function(g, h) {
    return g + h;
  };

  log = function() {
    var msgs;
    msgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.log.apply(console, msgs);
  };

}).call(this);

// Generated by CoffeeScript 1.3.1
(function() {
  var Entity, Fancy, Walker, Wanderer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Entity = (function() {

    Entity.name = 'Entity';

    function Entity(name, image, pos) {
      this.name = name != null ? name : 'thing';
      this.image = image != null ? image : 'sprite';
      this.pos = pos != null ? pos : [0, 0];
      this.init();
      this.debug = [];
    }

    Entity.prototype.init = function() {};

    Entity.prototype._update = function() {
      this.draw();
      return this.update();
    };

    Entity.prototype.draw = function() {
      window.Draw.use_layer('entities');
      return window.Draw.image(this.image, this.pos[0], this.pos[1]);
    };

    Entity.prototype.update = function() {};

    return Entity;

  })();

  Walker = (function(_super) {

    __extends(Walker, _super);

    Walker.name = 'Walker';

    function Walker() {
      return Walker.__super__.constructor.apply(this, arguments);
    }

    Walker.prototype.init = function() {
      this.state = 'idle';
      this.speed = 2.5;
      this.turn_speed = .02;
      this.target = 0;
      this.path = 0;
      this.vector = this.normalize_vector(new Vector(0, 1, 0));
      this.new_vector = false;
      this.tile_pos = [parseInt(this.pos[0] / window.Map.tilesize), parseInt(this.pos[1] / window.Map.tilesize)];
      this.wait_time = 0;
      this.total_time = 0;
      this.frame_count = 0;
      this.footprint_img = 'prints';
      this.velcoity = .1;
      this.draw_prints = 0;
      this.rotate_sprite = 1;
      this.pos = [this.pos[0] - this.pos[0] % 32, this.pos[1] - this.pos[1] % 32];
      this.sprite_size = 32;
      return this.sprite_offset = [0, 0];
    };

    Walker.prototype._update = function(delta) {
      this.delta_time = delta;
      this.total_time += delta;
      this.frame_count += 1;
      if (this[this.state] != null) {
        this[this.state]();
      }
      this.draw();
      return this.update();
    };

    Walker.prototype.draw = function() {
      var x, y;
      this.draw_sprite();
      window.Draw.context.fillStyle = 'white';
      this.debug = [];
      if (this.target) {
        x = this.target[0] * window.Map.tilesize;
        return y = this.target[1] * window.Map.tilesize;
      }
    };

    Walker.prototype.draw_sprite = function() {
      var rotation;
      rotation = false;
      if (this.vector && this.rotate_sprite) {
        rotation = Math.atan2(this.vector.y, this.vector.x);
        rotation += Math.PI + Math.PI / 2;
      }
      if (this.footprint_img) {
        if (this.draw_prints) {
          this.draw_prints = 0;
          window.Draw.use_layer('background');
          window.Draw.image(this.footprint_img, this.pos[0], this.pos[1], 32, 32, rotation);
        }
      }
      window.Draw.use_layer('entities');
      return window.Draw.image(this.image, this.pos[0] + this.sprite_offset[0], this.pos[1] + this.sprite_offset[0], this.sprite_size, this.sprite_size, rotation);
    };

    Walker.prototype.get_random_tile = function(distance) {
      var x, y;
      if (distance == null) {
        distance = false;
      }
      if (!distance) {
        x = parseInt(Math.random() * window.Map.width);
        y = parseInt(Math.random() * window.Map.height);
      } else {
        x = parseInt((Math.random() * distance * 2) - distance) + this.tile_pos[0];
        y = parseInt((Math.random() * distance * 2) - distance) + this.tile_pos[1];
        x = window.util.constrict(x, 0, window.Map.width);
        y = window.util.constrict(y, 0, window.Map.height);
      }
      return [x, y];
    };

    Walker.prototype.normalize_vector = function(vector) {
      var len;
      len = vector.length();
      vector = vector.unit().multiply(this.speed);
      return vector;
    };

    Walker.prototype.idle = function() {
      var path;
      this.target = this.get_random_tile(10);
      path = window.Entities.get_path(this.tile_pos[0], this.tile_pos[1], this.target[0], this.target[1]);
      if (path) {
        this.path = path;
        return this.state = 'moving';
      }
    };

    Walker.prototype.wait = function() {
      this.wait_time += this.delta_time;
      if (this.wait_time > 600) {
        this.wait_time = 0;
        return this.state = 'idle';
      }
    };

    Walker.prototype.rotating = function() {
      var fraction, p, r, r1, r2;
      this.wait_time += this.delta_time;
      p = Math.PI;
      r1 = Math.atan2(this.old_vector.y, this.old_vector.x) + p;
      r2 = Math.atan2(this.new_vector.y, this.new_vector.x) + p;
      if (r1 > r2) {
        r = r1 - r2;
      } else {
        r = r2 - r1;
      }
      this.rotate_speed = r * 300;
      if (this.wait_time > this.rotate_speed) {
        this.wait_time = 0;
        this.vector = this.new_vector;
        this.state = 'moving';
        return;
      }
      fraction = this.wait_time / this.rotate_speed;
      return this.vector = Vector.lerp(this.old_vector, this.new_vector, fraction);
    };

    Walker.prototype.moving = function() {
      var p1, p2, tilesize;
      tilesize = window.Map.tilesize;
      this.tile_pos = [parseInt(this.pos[0] / window.Map.tilesize), parseInt(this.pos[1] / window.Map.tilesize)];
      p1 = this.path[0][0] * tilesize;
      p2 = this.path[0][1] * tilesize;
      if (this.pos[0] > p1 - this.speed && this.pos[0] < p1 + this.speed && this.pos[1] > p2 - this.speed && this.pos[1] < p2 + this.speed) {
        this.pos = [p1, p2];
        this.tile_pos = this.path[0];
        this.path = this.path.splice(1, this.path.length);
        this.velocity = .1;
        if (this.path.length === 0) {
          this.target = 0;
          this.state = 'wait';
          return;
        }
        this.new_vector = this.normalize_vector(new Vector((this.path[0][0] * tilesize) - this.pos[0], (this.path[0][1] * tilesize) - this.pos[1], 0));
        this.old_vector = this.vector;
        return this.state = 'rotating';
      } else {
        this.velocity *= 1.1;
        if (this.velocity > 1.0) {
          this.velocity = 1.0;
        }
        this.pos[0] += this.new_vector.x * this.velocity;
        return this.pos[1] += this.new_vector.y * this.velocity;
      }
    };

    return Walker;

  })(Entity);

  Wanderer = (function(_super) {

    __extends(Wanderer, _super);

    Wanderer.name = 'Wanderer';

    function Wanderer() {
      return Wanderer.__super__.constructor.apply(this, arguments);
    }

    Wanderer.prototype.moving = function() {
      var near, p1, p2, tilesize;
      if (!(this.path != null) || this.path.length === 0) {
        this.state = 'wait';
        return;
      }
      tilesize = window.Map.tilesize;
      this.tile_pos = [parseInt(this.pos[0] / window.Map.tilesize), parseInt(this.pos[1] / window.Map.tilesize)];
      p1 = this.path[0][0] * tilesize;
      p2 = this.path[0][1] * tilesize;
      this.vect_to_target = new Vector((this.path[0][0] * tilesize) - this.pos[0], (this.path[0][1] * tilesize) - this.pos[1], 0);
      this.dist_to_target = this.vect_to_target.length();
      this.target_vect = this.normalize_vector(this.vect_to_target);
      this.vector = Vector.lerp(this.vector, this.target_vect, this.turn_speed);
      near = 10;
      if (this.pos[0] > p1 - near && this.pos[0] < p1 + near && this.pos[1] > p2 - near && this.pos[1] < p2 + near) {
        this.tile_pos = this.path[0];
        this.path = this.path.splice(1, this.path.length);
        this.velocity = .1;
        if (this.path.length === 0) {
          this.target = 0;
          this.state = 'wait';
        }
      } else {
        return this.move(1);
      }
    };

    Wanderer.prototype.move = function(friction) {
      var p, r, r1, r2;
      if (friction == null) {
        friction = .95;
      }
      this.vector = this.vector.multiply(.90);
      if (!this.vvv) {
        this.vvv = new Vector(0, 0, 0);
      }
      if (!this.dist_to_target) {
        return;
      }
      p = Math.PI + Math.PI / 2;
      r1 = Math.atan2(this.vector.y, this.vector.x) + p;
      r2 = Math.atan2(this.vect_to_target.y, this.vect_to_target.x) + p;
      if (r1 > r2) {
        r = r1 - r2;
      } else {
        r = r2 - r1;
      }
      if (r > .9) {
        r = .9;
      }
      if (r > .05) {
        friction = 1 - r * .2;
      }
      this.vvv = this.vvv.multiply(friction);
      this.vvv = this.vvv.add(this.vector.multiply(.2));
      if (this.vvv.length() > this.speed) {
        this.vvv = this.normalize_vector(this.vvv);
      }
      if (this.vvv.length() > this.speed / 3) {
        if (this.frame_count % 18 === 0) {
          this.draw_prints = 1;
        }
      }
      this.pos[0] += this.vvv.x;
      return this.pos[1] += this.vvv.y;
    };

    Wanderer.prototype.wait = function() {
      this.wait_time += this.delta_time;
      this.move(.8);
      if (this.wait_time > 600) {
        this.wait_time = 0;
        return this.state = 'idle';
      }
    };

    return Wanderer;

  })(Walker);

  Fancy = (function(_super) {

    __extends(Fancy, _super);

    Fancy.name = 'Fancy';

    function Fancy() {
      return Fancy.__super__.constructor.apply(this, arguments);
    }

    Fancy.prototype.draw_sprite = function() {
      var i, j, offset, rot, rotation, step, x, y;
      rotation = false;
      i = 0;
      j = 0;
      if (this.vvv) {
        rotation = Math.atan2(this.vvv.y, this.vvv.x);
        rotation += Math.PI;
        step = (2 * Math.PI) / 15;
        rot = Math.abs(parseInt(rotation / step));
        i = Math.floor(rot / 5);
        j = rot % 4;
        rotation += Math.PI / 2;
      }
      if (this.footprint_img) {
        if (this.draw_prints) {
          this.draw_prints = 0;
          window.Draw.use_layer('background');
          window.Draw.image(this.footprint_img, this.pos[0], this.pos[1], 32, 32, rotation);
        }
      }
      window.Draw.use_layer('entities');
      x = this.pos[0] + this.sprite_offset[0];
      y = this.pos[1] + this.sprite_offset[0];
      window.Draw.image('shadow', this.pos[0] - 6, this.pos[1] + 16, 32, 16);
      return window.Draw.sub_image(this.image, x, y + this.sprite_offset[1], this.sprite_size, this.sprite_size, 128, offset = [i, j]);
    };

    Fancy.prototype.wait = function() {
      this.wait_time += this.delta_time;
      if (this.wait_time > 300) {
        this.wait_time = 0;
        this.state = 'jump';
        return this.jump_v = -3;
      }
    };

    Fancy.prototype.jump = function() {
      this.jump_v += .1;
      this.sprite_offset[1] = this.sprite_offset[1] + this.jump_v;
      if (this.jump_v > 3) {
        this.jump_v = 3;
        this.state = 'idle';
        return this.sprite_offset[1] = 0;
      }
    };

    return Fancy;

  })(Wanderer);

  window.Entities = {
    init: function() {
      var advanced, i, x, y, _i, _results;
      window.Events.add_listener(this);
      this.classes = {
        Entity: Entity,
        Walker: Walker,
        Wanderer: Wanderer
      };
      this.path_finder = new PF.JumpPointFinder();
      this.sentient = [];
      _results = [];
      for (i = _i = 0; _i <= 10; i = ++_i) {
        x = parseInt(Math.random() * (window.Map.width * window.Map.tilesize));
        y = parseInt(Math.random() * (window.Map.width * window.Map.tilesize));
        advanced = new Fancy('Joe', 'testy', [x, y]);
        advanced.speed = 1.5;
        advanced.sprite_offset = [-16, 0];
        advanced.sprite_size = 48;
        _results.push(this.sentient.push(advanced));
      }
      return _results;
    },
    update: function(delta) {
      var thing, _i, _len, _ref, _results;
      if (this.sentient != null) {
        _ref = this.sentient;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          thing = _ref[_i];
          _results.push(thing._update(delta));
        }
        return _results;
      }
    },
    get_path: function(x, y, x2, y2) {
      var grid;
      grid = new PF.Grid(window.Map.width, window.Map.height, window.Map.arrays['pathfinding']);
      try {
        return this.path_finder.findPath(x, y, x2, y2, grid);
      } catch (error) {
        return false;
      }
    },
    add_class: function(name, ancestor) {
      if (ancestor == null) {
        ancestor = 'Entity';
      }
      if (this.classes[name] != null) {
        return false;
      }
      if (this.classes[ancestor] != null) {
        eval("this.classes[name] = (function(_super) {          __extends(" + name + ", _super);          function " + name + "() {            return " + name + ".__super__.constructor.apply(this, arguments);          }          return " + name + ";        })(this.classes[ancestor]);");
        return this.classes[name];
      }
    }
  };

  $(window).ready(function() {
    window.Draw.add_image('tracks', "./textures/tracks.png");
    window.Draw.add_image('prints', "./textures/prints.png");
    window.Draw.add_image('testy', "./textures/astronauts/astrosheet.png");
    window.Draw.add_image('shadow', "./textures/astronauts/shadow.png");
    return window.Entities.init();
  });

}).call(this);
